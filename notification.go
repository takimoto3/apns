// package apns provides a client for sending notifications to the Apple Push Notification service.
package apns

import (
	"errors"
	"fmt"

	"github.com/google/uuid"
	"github.com/takimoto3/apns/notification"
	"github.com/takimoto3/apns/notification/priority"
)

// Notification represents a complete APNs notification request.
// It contains all the headers and the payload to be sent to the APNs server.
type Notification struct {
	// BundleID is the bundle identifier of the target app.
	// This string is used to generate the `apns-topic` header.
	// See the `Topic()` method for more details on how the topic is derived.
	BundleID string

	// Type is the push type of the notification.
	// This value is used for the `apns-push-type` header.
	Type notification.PushType

	// APNsID is a canonical UUID that identifies the notification.
	// If you omit this, a new UUID is generated by APNs and returned in the response.
	// Corresponds to the `apns-id` header.
	APNsID string

	// Expiration specifies the time at which the notification is no longer valid.
	// This corresponds to the `apns-expiration` header.
	// A zero value means the notification expires immediately.
	Expiration *notification.EpochTime

	// Priority is the priority of the notification.
	// This corresponds to the `apns-priority` header.
	Priority priority.Priority

	// CollapseID is an identifier used to group related notifications.
	// This corresponds to the `apns-collapse-id` header.
	CollapseID string

	// DeviceToken is the hexadecimal string that uniquely identifies the device.
	// This is part of the request URL.
	DeviceToken string

	// Payload is the JSON payload of the notification.
	Payload *Payload
}

// Topic returns the appropriate `apns-topic` header value based on the notification's
// BundleID and PushType.
//
// For most push types, the topic is simply the BundleID. For special types like
// `voip`, `complication`, or `liveactivity`, a specific suffix is appended to the
// BundleID as required by APNs.
func (n Notification) Topic() string {
	bundleID := n.BundleID
	switch n.Type {
	case notification.Alert, notification.Background:
		return bundleID
	case notification.Complication:
		return bundleID + ".complication"
	case notification.Controls:
		return bundleID + ".push-type.controls"
	case notification.Fileprovider:
		return bundleID + ".pushkit.fileprovider"
	case notification.Liveactivity:
		return bundleID + ".push-type.liveactivity"
	case notification.Location:
		return bundleID + ".location-query"
	case notification.Mdm:
		return bundleID
	case notification.Pushtotalk:
		return bundleID + ".voip-ptt"
	case notification.Voip:
		return bundleID + ".voip"
	case notification.Widgets:
		return bundleID + ".push-type.widgets"
	default:
		return bundleID // fallback for unknown types
	}
}

// Validate checks if the notification is well-formed before sending it.
// It validates the presence of required fields like BundleID, DeviceToken, and Type.
// It also checks the format of APNsID (if present) and the validity of other fields.
func (n *Notification) Validate() error {
	if n.BundleID == "" {
		return errors.New("BundleID is required")
	}
	// Validate DeviceToken (non-empty only)
	if n.DeviceToken == "" {
		return errors.New("DeviceToken is required")
	}

	if n.Type == "" {
		return errors.New("apns-push-type is required")
	}

	// Validate PushType
	switch n.Type {
	case notification.Alert, notification.Background, notification.Complication, notification.Controls,
		notification.Fileprovider, notification.Liveactivity, notification.Location, notification.Mdm,
		notification.Pushtotalk, notification.Voip, notification.Widgets:
		// Valid PushType
	default:
		return fmt.Errorf("invalid apns-push-type: %s", n.Type)
	}

	if n.APNsID != "" {
		if _, err := uuid.Parse(n.APNsID); err != nil {
			return fmt.Errorf("invalid APNsID: %w", err)
		}
	}

	// Validate Priority
	switch n.Priority {
	case priority.None, priority.PowerOnly, priority.Conserve, priority.Immediate:
		// Valid Priority
	default:
		return fmt.Errorf("invalid apns-priority: %d", n.Priority)
	}

	// Validate Payload presence for specific push types
	if n.Type == notification.Alert || n.Type == notification.Background {
		if n.Payload == nil {
			return fmt.Errorf("Payload is required for %s push type", n.Type)
		}
	}

	if n.Payload != nil {
		if err := n.Payload.APS.Validate(); err != nil {
			return err
		}
	}

	return nil
}

func (n *Notification) Clone() *Notification {
	c := *n
	return &c
}
